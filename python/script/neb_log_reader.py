#!/usr/bin/env python3
import numpy as np
from io import StringIO
import warnings


class NEBLogReader:
    '''
    Read NEB calculation results
    '''
    scalar_key = ['Step', 'MaxReplicaForce', 'MaxAtomForce',
                  'GradV0', 'GradV1', 'GradVc', 'EBF', 'EBR', 'RDT']
    vector_key = ['RD', 'PE', 'pathangle', 'angletangrad',
                  'anglegrad', 'gradV', 'RepForce', 'MaxAtomForce']
    vector_units = {
        'PE': 'eV',
        'pathangle': 'degree',  # 180 for linear path
        'angletangrad': 'degree',  # angle between energy gradient and path; should be 0 or 180
        'anglegrad': 'degree',  # angle between energy gradient
        'gradV': r'eV/\AA',  # energy gradient; approximately equal to dPE/dRD;
        'RepForce': r'eV/\AA',  # force norm including nudging force
        'MaxAtomForce': r'eV/\AA'  # force norm not including nudging force
    }

    def __init__(self, prop=[]):
        self.scalar_prop = set()
        self.vector_prop = {'RD', 'PE'}

        for p in prop:
            if p == 'MaxAtomForce':
                self.scalar_prop.add(p)
                self.vector_prop.add(p)
            else:
                if p in NEBLogReader.scalar_key:
                    self.scalar_prop.add(p)
                elif p in NEBLogReader.vector_key:
                    self.vector_prop.add(p)

        self.scalar_data_dict = {}
        self.vector_data_dict = {}
        for sp in self.scalar_prop:
            self.scalar_data_dict[sp] = []
        for vp in self.vector_prop:
            self.vector_data_dict[vp] = []

    def read_global_log(self, fname='log.lammps'):
        '''
        Read global log file generated by NEB calculations
        Store converged results in variables defined in self.__init__ section
        '''
        f = open(fname, 'r')
        while True:
            line = f.readline()
            if line == '':
                break
            if self._is_neb_header(line):
                self._parse_neb_data(f, line)

    def get_neb_data(self, key='PE', idx=1):
        '''
        Return the idx th NEB data
        '''
        if key in self.vector_prop:
            return self.vector_data_dict[key][idx]
        elif key in self.scalar_prop:
            return self.scalar_data_dict[key][idx]

    def _is_neb_header(self, line):
        '''
        Check if the line is a NEB header
        '''
        words = line.split()
        neb_header = NEBLogReader.scalar_key
        for i in range(len(neb_header)):
            if neb_header[i] != words[i]:
                return False
        return True

    def _default_header(self, neb_header_line):
        '''
        Lammps header printing bug: no space between angletangrad10anglegrad10
        '''
        neb_header = neb_header_line.split()
        if 'pathangle1' in neb_header:
            verbosity = 2  # 'verbose'
        elif 'PE1' in neb_header:
            verbosity = 1  # 'default'
        else:
            verbosity = 0  # 'terse'

        # terse mode header
        ret = []
        ret.extend(NEBLogReader.scalar_key)
        if verbosity == 0:
            return ret

        num_replica = 0
        while True:
            if not 'RD'+str(num_replica+1) in neb_header:
                break
            num_replica += 1

        # default mode header
        keys = NEBLogReader.vector_key[:2]
        for i in range(1, num_replica+1):
            tmp = [k+str(i) for k in keys]
            ret.extend(tmp)
        if verbosity == 1:
            return ret

        # verbose mode header
        keys = NEBLogReader.vector_key[2:]
        for i in range(1, num_replica+1):
            tmp = [k+str(i) for k in keys]
            ret.extend(tmp)
        if verbosity == 2:
            return ret

    def _parse_neb_data(self, f, neb_header_line):
        '''
        Read NEB data lines to the end
        '''
        while True:
            floc = f.tell()
            line = f.readline()
            if line == '':
                break
            try:
                sio = StringIO(line)
                data = np.loadtxt(sio)
                floc_last = floc
            except ValueError:
                f.seek(floc_last, 0)
                line = f.readline()
                sio = StringIO(line)
                data = np.loadtxt(sio)
                break
        neb_header = neb_header_line.split()
        if len(neb_header) != len(data):
            neb_header = self._default_header(neb_header_line)
            warnings.warn("Using user generated header")
        idx = {}
        for vp in self.vector_prop:
            idx[vp] = np.full(len(neb_header), False)
        for i in range(len(neb_header)):
            if neb_header[i] in self.scalar_prop:
                key = neb_header[i]
                self.scalar_data_dict[key].append(data[i])
            elif neb_header[i].rstrip('0123456789') in self.vector_prop:
                key = neb_header[i].rstrip('0123456789')
                idx[key][i] = True
        for vp in self.vector_prop:
            self.vector_data_dict[vp].append(data[idx[vp]])

    def read_partition_log(self, fnames='log.lammps.*'):
        pass

    def plot(self, prop='PE', idx_all=[1], ofname='neb', req_data=False):
        import pandas as pd
        from scipy.interpolate import make_interp_spline
        import sys
        from pathlib import Path
        sys.path.append(str(Path.home()/'template/python/src/matplotlib'))
        from default_setup import mpl_default
        import matplotlib.pyplot as plt
        import matplotlib as mpl
        mpl.use('Agg')

        mpld = mpl_default()
        mpld.setup(fontsize=12)
        fig, ax = plt.subplots(figsize=(4, 3), layout='tight')
        for idx in idx_all:
            x = self.get_neb_data(key='RD', idx=idx)
            y = self.get_neb_data(key=prop, idx=idx)
            if len(x) != len(y):
                raise Exception("Length of property does not match !!!")
            isnan = np.isnan(y)
            if np.any(isnan):
                warnings.warn("Ignore nan identified in "+prop)
            x = x[np.logical_not(isnan)]
            y = y[np.logical_not(isnan)]
            if prop == 'PE':
                y = y-y[0]
            if req_data:
                data = pd.DataFrame({'RD': x, 'PE': y})
                data.to_csv(ofname+'_'+prop+'_'+str(idx) +
                            '.dat', sep=' ', index=None)

            color = next(mpld.color2)
            ax.plot(x, y, 'o--', color=color,
                     markerfacecolor='None', label=str(idx))

        ax.set_xlim(0, 1)
        ax.set_xlabel(r'Reaction Coordinate')
        ylabel = prop
        if prop in NEBLogReader.vector_units:
            ylabel += ' ('+NEBLogReader.vector_units[prop]+')'
        ax.set_ylabel(ylabel)
        ax.grid()
        ax.legend()
        fig.tight_layout()
        fig.savefig(ofname+'_'+prop+'.pdf')


def main():
    import argparse
    import os
    from pathlib import Path
    parser = argparse.ArgumentParser(
        prog="python3 neb_energy.py",
        description="NEB energetics from log file",
        epilog="Written by LI Songwei"
    )
    parser.add_argument('-l', '--log_fname', type=str,
                        default='log.neb', help='NEB log file')
    parser.add_argument('-n', '--number', type=int, nargs='*',
                        default=[1], help='Which data to plot')
    parser.add_argument('-p', '--prop', type=str, nargs='*',
                        default=['PE'], help='Which property to plot')
    parser.add_argument('-o', '--fig_name', type=str,
                        default="NEB", help='Output figure name')

    args = parser.parse_args()
    neb_log_reader = NEBLogReader(prop=args.prop)
    neb_log_reader.read_global_log(args.log_fname)
    for p in args.prop:
        neb_log_reader.plot(prop=p, idx_all=args.number, ofname=args.fig_name)


if __name__ == '__main__':
    main()
